{
  "title": "Operating Systems Quiz",
  "categories": [
    {
      "id": "week1",
      "name": "Week 1: Bash Scripting",
      "questions": [
        {
          "question": "Welke regel moet altijd als EERSTE in een Bash-script staan om aan te geven welke shell gebruikt wordt?",
          "options": [
            "# /bin/bash",
            "#!/bin/bash",
            "/bin/bash!",
            "shell=/bin/bash"
          ],
          "correct": 1,
          "explanation": "De shebang '#!/bin/bash' (uitgesproken als 'hash-bang') moet op de eerste regel staan. Dit vertelt het systeem met welke interpreter het script uitgevoerd moet worden. Alleen '#' zonder '!' is gewone commentaar."
        },
        {
          "question": "Een student schrijft het volgende: naam = \"Peter\". Wat is er fout?",
          "options": [
            "De variabelenaam mag geen hoofdletters bevatten",
            "Er mogen geen spaties rondom het =-teken staan bij variabeletoewijzing",
            "Dubbele aanhalingstekens zijn niet toegestaan in Bash",
            "De variabele moet beginnen met een $-teken"
          ],
          "correct": 1,
          "explanation": "In Bash zijn spaties rondom '=' niet toegestaan bij variabeletoewijzing. Bash interpreteert 'naam' dan als een commando met '=' als argument. De correcte schrijfwijze is: naam=\"Peter\"."
        },
        {
          "question": "Wat is de uitvoer van het volgende script?\nnaam=linux\necho 'Welkom bij $naam'",
          "options": [
            "Welkom bij linux",
            "Welkom bij $naam",
            "Er treedt een foutmelding op",
            "Welkom bij"
          ],
          "correct": 1,
          "explanation": "Binnen enkele aanhalingstekens (' ') verliezen speciale tekens zoals '$' hun betekenis. De variabele wordt dus NIET uitgebreid. De letterlijke tekst '$naam' wordt afgedrukt."
        },
        {
          "question": "Welk commando maakt een script-bestand uitvoerbaar?",
          "options": [
            "exec +x mijnscript.sh",
            "run mijnscript.sh",
            "chmod +x mijnscript.sh",
            "bash --enable mijnscript.sh"
          ],
          "correct": 2,
          "explanation": "'chmod +x bestand' past de bestandspermissies aan en voegt de execute-permissie toe. Hierna kan het script worden uitgevoerd met './mijnscript.sh'."
        },
        {
          "question": "Wat geeft de speciale variabele $# terug in een Bash-script?",
          "options": [
            "De naam van het script",
            "Het proces-ID van het script",
            "Het aantal argumenten dat is meegegeven",
            "De exitcode van het vorige commando"
          ],
          "correct": 2,
          "explanation": "$# geeft het aantal argumenten terug dat aan het script is meegegeven. Bijvoorbeeld: './script.sh a b c' geeft $# de waarde 3. Niet te verwarren met $0 (scriptnaam), $$ (PID) of $? (exitcode)."
        },
        {
          "question": "Een script wordt aangeroepen als: ./test.sh appel peer banaan. Wat is de waarde van $2?",
          "options": [
            "appel",
            "test.sh",
            "peer",
            "banaan"
          ],
          "correct": 2,
          "explanation": "$0 is de naam van het script (./test.sh), $1 is het eerste argument (appel), $2 is het tweede argument (peer), $3 is het derde argument (banaan)."
        },
        {
          "question": "Welke operator wordt gebruikt om uitvoer TOE TE VOEGEN aan een bestaand bestand (zonder het te overschrijven)?",
          "options": [
            ">",
            ">>",
            "2>",
            "|"
          ],
          "correct": 1,
          "explanation": "'>>' voegt uitvoer toe aan het einde van een bestand. '>' overschrijft het bestand volledig. '2>' stuurt foutmeldingen (stderr) naar een bestand. '|' is een pipe om uitvoer door te sturen naar een ander commando."
        },
        {
          "question": "Wat is de functie van '2> /dev/null' in een Bash-commando?",
          "options": [
            "De standaarduitvoer wordt naar een bestand gestuurd",
            "Foutmeldingen worden weggegooid en niet getoond",
            "Het script wordt naar de achtergrond gestuurd",
            "De tweede uitvoerstroom wordt omgeleid naar de terminal"
          ],
          "correct": 1,
          "explanation": "'2>' stuurt de foutuitvoer (stderr, stream 2) om. '/dev/null' is een speciaal bestand dat alles wat ernaar geschreven wordt weggooit. Dit is handig als je foutmeldingen wilt onderdrukken."
        },
        {
          "question": "Welke vergelijkingsoperator gebruik je om te controleren of een getal KLEINER DAN OR GELIJK AAN een ander getal is in Bash?",
          "options": [
            "-lt",
            "-ne",
            "-le",
            "-ge"
          ],
          "correct": 2,
          "explanation": "-le staat voor 'less than or equal'. -lt is 'less than', -ge is 'greater than or equal', -ne is 'not equal'. Onthoud: l=less, g=greater, e=equal, t=than, n=not."
        },
        {
          "question": "Wat is de uitvoer van dit script?\nfor i in {1..3}\ndo\n  echo \"Nummer: $i\"\ndone",
          "options": [
            "Nummer: 1 Nummer: 2 Nummer: 3 (op één regel)",
            "Nummer: 1\nNummer: 2\nNummer: 3 (elk op nieuwe regel)",
            "Nummer: {1..3}",
            "Er treedt een foutmelding op omdat de accolades niet geldig zijn"
          ],
          "correct": 1,
          "explanation": "De brace-expansie {1..3} genereert de reeks 1, 2, 3. De for-loop doorloopt elk getal en echo plaatst elke uitvoer op een nieuwe regel. De uitvoer is dus drie regels: Nummer: 1, Nummer: 2, Nummer: 3."
        },
        {
          "question": "Welke constructie wordt een 'here-document' genoemd?",
          "options": [
            "echo \"tekst\" > bestand.txt",
            "cat << EOF > bestand.txt ... EOF",
            "read VARIABELE << bestand.txt",
            "cat bestand.txt | echo"
          ],
          "correct": 1,
          "explanation": "Een here-document (cat << EOF ... EOF) stelt je in staat om meerdere regels tekst direct in een script in te sluiten en naar een bestand of commando te sturen. Alles tussen << EOF en EOF wordt als invoer behandeld."
        },
        {
          "question": "Wat doet het 'shift'-commando in een Bash-script?",
          "options": [
            "Het verplaatst de cursor naar rechts in de terminal",
            "Het schuift alle positionele argumenten één positie naar links, waardoor $2 de nieuwe $1 wordt",
            "Het verdubbelt het aantal beschikbare argumenten",
            "Het verwijdert het laatste argument uit de lijst"
          ],
          "correct": 1,
          "explanation": "'shift' schuift de positionele parameters op: na shift wordt $2 de nieuwe $1, $3 de nieuwe $2, etc. en $# daalt met 1. Dit is handig in while-loops om één voor één door argumenten te lopen."
        },
        {
          "question": "Wat is de uitvoer van het volgende script als het wordt aangeroepen zonder argumenten?\n#!/bin/bash\nif [[ $# -gt 0 ]]\nthen\n  echo \"Er zijn argumenten\"\nelse\n  echo \"Geen argumenten\"\nfi",
          "options": [
            "Er zijn argumenten",
            "Geen argumenten",
            "Het script geeft een foutmelding",
            "Het script geeft geen uitvoer"
          ],
          "correct": 1,
          "explanation": "Als het script zonder argumenten wordt aangeroepen is $# gelijk aan 0. De conditie '$# -gt 0' (groter dan 0) is dan ONWAAR, waardoor het else-blok wordt uitgevoerd: 'Geen argumenten'."
        },
        {
          "question": "Welk commando gebruik je in Bash om invoer van de gebruiker in te lezen en op te slaan in een variabele IPMASTER?",
          "options": [
            "input IPMASTER",
            "scan IPMASTER",
            "read IPMASTER",
            "get $IPMASTER"
          ],
          "correct": 2,
          "explanation": "'read VARIABELE' leest een regel invoer van de gebruiker (stdin) en slaat deze op in de opgegeven variabele. 'input', 'scan' en 'get' zijn geen geldige Bash-commando's voor gebruikersinvoer."
        },
        {
          "question": "Hoe voer je een commando uit op een remote server 'gameserver01' via SSH vanuit een Bash-script?",
          "options": [
            "remote gameserver01 \"commando\"",
            "ssh gameserver01 \"commando\"",
            "connect gameserver01 && commando",
            "bash gameserver01 \"commando\""
          ],
          "correct": 1,
          "explanation": "'ssh hostname \"commando\"' voert een commando uit op een remote host zonder interactieve sessie. Dit is de standaard manier voor geautomatiseerd remote beheer in Bash-scripts."
        },
        {
          "question": "Wat is het verschil tussen $@ en $* in Bash?",
          "options": [
            "Er is geen verschil, beide geven alle argumenten terug",
            "$@ geeft het aantal argumenten, $* geeft alle argumenten als tekst",
            "Bij gebruik binnen dubbele aanhalingstekens behandelt $@ elk argument apart, terwijl $* ze samenvoegt tot één string",
            "$* geeft alleen de oneven argumenten, $@ geeft alle argumenten"
          ],
          "correct": 2,
          "explanation": "Buiten aanhalingstekens gedragen $@ en $* zich hetzelfde. Binnen dubbele aanhalingstekens is het verschil cruciaal: \"$@\" behoudt elk argument als aparte eenheid (\"$1\" \"$2\" ...), terwijl \"$*\" alles samenvoegt tot één string (\"$1 $2 ...\")."
        },
        {
          "question": "Welke shell wordt in dit vak gebruikt en wat betekent de afkorting?",
          "options": [
            "/bin/csh – C Shell, ontwikkeld door Sun Microsystems",
            "/bin/ksh – Korn Shell, de standaard POSIX-shell",
            "/bin/bash – Bourne Again Shell, een GNU-versie van de Bourne shell",
            "/bin/sh – Super Shell, de modernste Unix-shell"
          ],
          "correct": 2,
          "explanation": "In dit vak wordt /bin/bash gebruikt: de Bourne Again Shell. Dit is een GNU-project dat de originele Bourne Shell (/bin/sh) verbetert en uitbreidt. Het is de standaardshell op de meeste Linux-distributies."
        },
        {
          "question": "Hoe wordt command substitution correct toegepast in een for-loop?",
          "options": [
            "for file in [ls]",
            "for file in $(ls)",
            "for file in {ls}",
            "for file in $ls"
          ],
          "correct": 1,
          "explanation": "Command substitution met $(commando) voert het commando uit en gebruikt de uitvoer als waarde. 'for file in $(ls)' voert 'ls' uit en gebruikt elke bestandsnaam als iteratiewaarde. De oudere backtick-notatie (`ls`) werkt ook maar is minder leesbaar."
        },
        {
          "question": "Wat is de correcte manier om een while-loop te schrijven die telt van 0 t/m 2?",
          "options": [
            "while [[ $i -le 2 ]] do\n  echo $i\n  ((i++))\ndone",
            "i=0\nwhile [[ $i -le 2 ]]\ndo\n  echo $i\n  ((i++))\ndone",
            "i=0\nwhile $i <= 2\ndo\n  echo $i\ndone",
            "i=0\nwhile [[ $i < 3 ]]\ndo\n  echo $i\n  i+1\ndone"
          ],
          "correct": 1,
          "explanation": "De correcte structuur vereist: (1) initialisatie van de teller vóór de loop, (2) de conditie in [[ ]] met -le voor 'less than or equal', (3) do op een nieuwe regel, en (4) een increment met ((i++)) binnen het loop-lichaam."
        },
        {
          "question": "Wat is het pad van de Bash-shell dat in de shebang-regel wordt gebruikt?",
          "options": [
            "/usr/bash",
            "/bin/sh",
            "/usr/bin/bash",
            "/bin/bash"
          ],
          "correct": 3,
          "explanation": "Het standaard pad van Bash is /bin/bash. Dit is het absolute pad dat in de shebang-regel (#!/bin/bash) gebruikt wordt. /bin/sh verwijst naar de POSIX shell (niet altijd Bash), en /usr/bin/bash bestaat doorgaans niet op standaard Linux-systemen."
        },
        {
          "question": "VERHAALVRAAG: Sysadmin Sara beheert 5 Ubuntu-servers: web01, web02, db01, db02 en mail01. Ze wil een Bash-script schrijven dat op alle servers het pakket 'nginx' installeert. Ze wil de servernamen NIET hardcoden in het script, zodat het flexibel inzetbaar blijft. Welk script is de BESTE oplossing?",
          "options": [
            "#!/bin/bash\nssh web01 \"apt install nginx\"\nssh web02 \"apt install nginx\"\nssh db01 \"apt install nginx\"\nssh db02 \"apt install nginx\"\nssh mail01 \"apt install nginx\"",
            "#!/bin/bash\nfor server in $@\ndo\n  echo \"Installeren op $server...\"\n  ssh $server \"apt install -y nginx\"\ndone",
            "#!/bin/bash\nread server\nssh $server \"apt install nginx\"",
            "#!/bin/bash\nif [[ $1 == \"nginx\" ]]\nthen\n  ssh web01 \"apt install $1\"\nfi"
          ],
          "correct": 1,
          "explanation": "Optie B is correct. Door $@ te gebruiken ontvangt het script alle servernamen als argumenten (aanroep: ./installeer.sh web01 web02 db01 db02 mail01). De for-loop itereert over elke server en voert het SSH-commando uit. Dit is flexibel: je kunt het script gebruiken voor 1 of 100 servers zonder aanpassing. Optie A hardcodeert alle namen (niet flexibel), C leest maar 1 server in, D is afhankelijk van een vaste pakketnaam."
        },
        {
          "question": "VERHAALVRAAG: Thomas is net aangesteld als IT-beheerder bij Orcs Nest. Hij schrijft een script dat dagelijks controleert of een back-upbestand bestaat. Als het bestand '/backup/orcsnest_backup.tar.gz' bestaat, schrijft hij 'Backup OK' naar een logbestand. Als het niet bestaat, schrijft hij 'FOUT: Geen backup gevonden!' naar hetzelfde logbestand. Hij wil dat berichten TOEGEVOEGD worden aan het logbestand, niet overschreven. Welke aanpak is correct?",
          "options": [
            "#!/bin/bash\nif [[ -z /backup/orcsnest_backup.tar.gz ]]\nthen\n  echo \"Backup OK\" > /var/log/backup.log\nelse\n  echo \"FOUT: Geen backup gevonden!\" > /var/log/backup.log\nfi",
            "#!/bin/bash\nif [[ -f /backup/orcsnest_backup.tar.gz ]]\nthen\n  echo \"Backup OK\" >> /var/log/backup.log\nelse\n  echo \"FOUT: Geen backup gevonden!\" >> /var/log/backup.log\nfi",
            "#!/bin/bash\nread /backup/orcsnest_backup.tar.gz\nif [[ $? -eq 0 ]]\nthen\n  echo \"Backup OK\" >> /var/log/backup.log\nfi",
            "#!/bin/bash\nfor file in /backup/\ndo\n  echo \"Backup OK\" >> /var/log/backup.log\ndone"
          ],
          "correct": 1,
          "explanation": "Optie B is correct om meerdere redenen: (1) '-f' test of een regulier BESTAND bestaat (niet '-z' wat een lege STRING test), (2) '>>' voegt toe aan het logbestand in plaats van het te overschrijven, (3) zowel het succes- als het foutbericht worden correct afgehandeld. Optie A gebruikt de verkeerde test (-z) én overschrijft het logbestand elke keer (>). Opties C en D zijn logisch onjuist voor dit doel."
        },
        {
          "question": "VERHAALVRAAG: Theresa werkt als websitebeheerder bij Orcs Nest. Ze heeft een script geschreven dat de namen van alle nieuwe medewerkers inleest uit een bestand 'medewerkers.txt' (één naam per regel) en voor elke medewerker een welkomstbericht naar het scherm schrijft én naar een bestand 'welkom_log.txt' toevoegt. Ze test het script maar ziet dat welkom_log.txt elke keer wordt overschreven in plaats van aangevuld. Bovendien wil ze dat eventuele foutmeldingen niet op het scherm verschijnen. Wat moet ze aanpassen?",
          "options": [
            "De while-loop vervangen door een for-loop en 2> toevoegen aan het echo-commando",
            "De '>' bij het wegschrijven vervangen door '>>' en '2> /dev/null' toevoegen aan het script of het relevante commando",
            "Het script uitvoeren met 'bash -s script.sh' zodat berichten automatisch worden toegevoegd",
            "Een aparte variabele aanmaken die bijhoudt hoeveel regels er al in welkom_log.txt staan"
          ],
          "correct": 1,
          "explanation": "Optie B pakt beide problemen aan: (1) '>' vervangen door '>>' zorgt dat output wordt TOEGEVOEGD in plaats van overschreven – cruciaal voor logbestanden die historische data moeten bewaren. (2) '2> /dev/null' stuurt foutmeldingen (stderr) weg zodat ze niet op het scherm verschijnen. Dit zijn twee fundamentele I/O-omleidingstechnieken die in combinatie gebruikt worden in professionele beheersscripts."
        }
      ]
    },
    {
      "id": "week2",
      "name": "Week 2: Binnenkort",
      "questions": []
    },
    {
      "id": "week3",
      "name": "Week 3: Binnenkort",
      "questions": []
    },
    {
      "id": "week4",
      "name": "Week 4: Binnenkort",
      "questions": []
    },
    {
      "id": "week5",
      "name": "Week 5: Binnenkort",
      "questions": []
    },
    {
      "id": "week6",
      "name": "Week 6: Binnenkort",
      "questions": []
    },
    {
      "id": "week7",
      "name": "Week 7: Binnenkort",
      "questions": []
    },
    {
      "id": "examen",
      "name": "Examen: Binnenkort",
      "questions": []
    }
  ]
}